.TH "QwtWheel" 3 "Thu Dec 11 2014" "Version 6.1.2" "Qwt User's Guide" \" -*- nroff -*-
.ad l
.nh
.SH NAME
QwtWheel \- 
.PP
The Wheel Widget\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <qwt_wheel\&.h>\fP
.PP
Inherits QWidget\&.
.SS "Public Slots"

.in +1c
.ti -1c
.RI "void \fBsetValue\fP (double)"
.br
.RI "\fISet a new value without adjusting to the step raster\&. \fP"
.ti -1c
.RI "void \fBsetTotalAngle\fP (double)"
.br
.RI "\fISet the total angle which the wheel can be turned\&. \fP"
.ti -1c
.RI "void \fBsetViewAngle\fP (double)"
.br
.RI "\fISpecify the visible portion of the wheel\&. \fP"
.ti -1c
.RI "void \fBsetMass\fP (double)"
.br
.RI "\fISet the slider's mass for flywheel effect\&. \fP"
.in -1c
.SS "Signals"

.in +1c
.ti -1c
.RI "void \fBvalueChanged\fP (double \fBvalue\fP)"
.br
.RI "\fINotify a change of value\&. \fP"
.ti -1c
.RI "void \fBwheelPressed\fP ()"
.br
.ti -1c
.RI "void \fBwheelReleased\fP ()"
.br
.ti -1c
.RI "void \fBwheelMoved\fP (double \fBvalue\fP)"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBQwtWheel\fP (QWidget *parent=NULL)"
.br
.RI "\fIConstructor\&. \fP"
.ti -1c
.RI "virtual \fB~QwtWheel\fP ()"
.br
.RI "\fIDestructor\&. \fP"
.ti -1c
.RI "double \fBvalue\fP () const "
.br
.ti -1c
.RI "void \fBsetOrientation\fP (Qt::Orientation)"
.br
.RI "\fISet the wheel's orientation\&. \fP"
.ti -1c
.RI "Qt::Orientation \fBorientation\fP () const "
.br
.ti -1c
.RI "double \fBtotalAngle\fP () const "
.br
.ti -1c
.RI "double \fBviewAngle\fP () const "
.br
.ti -1c
.RI "void \fBsetTickCount\fP (int)"
.br
.RI "\fIAdjust the number of grooves in the wheel's surface\&. \fP"
.ti -1c
.RI "int \fBtickCount\fP () const "
.br
.ti -1c
.RI "void \fBsetWheelWidth\fP (int)"
.br
.RI "\fISet the width of the wheel\&. \fP"
.ti -1c
.RI "int \fBwheelWidth\fP () const "
.br
.ti -1c
.RI "void \fBsetWheelBorderWidth\fP (int)"
.br
.RI "\fISet the wheel border width of the wheel\&. \fP"
.ti -1c
.RI "int \fBwheelBorderWidth\fP () const "
.br
.ti -1c
.RI "void \fBsetBorderWidth\fP (int)"
.br
.RI "\fISet the border width\&. \fP"
.ti -1c
.RI "int \fBborderWidth\fP () const "
.br
.ti -1c
.RI "void \fBsetInverted\fP (bool tf)"
.br
.RI "\fIEn/Disable inverted appearance\&. \fP"
.ti -1c
.RI "bool \fBisInverted\fP () const "
.br
.ti -1c
.RI "void \fBsetWrapping\fP (bool tf)"
.br
.RI "\fIEn/Disable wrapping\&. \fP"
.ti -1c
.RI "bool \fBwrapping\fP () const "
.br
.ti -1c
.RI "void \fBsetSingleStep\fP (double)"
.br
.RI "\fISet the step size of the counter\&. \fP"
.ti -1c
.RI "double \fBsingleStep\fP () const "
.br
.ti -1c
.RI "void \fBsetPageStepCount\fP (int)"
.br
.RI "\fISet the page step count\&. \fP"
.ti -1c
.RI "int \fBpageStepCount\fP () const "
.br
.ti -1c
.RI "void \fBsetStepAlignment\fP (bool on)"
.br
.RI "\fIEn/Disable step alignment\&. \fP"
.ti -1c
.RI "bool \fBstepAlignment\fP () const "
.br
.ti -1c
.RI "void \fBsetRange\fP (double vmin, double vmax)"
.br
.RI "\fISet the minimum and maximum values\&. \fP"
.ti -1c
.RI "void \fBsetMinimum\fP (double min)"
.br
.ti -1c
.RI "double \fBminimum\fP () const "
.br
.ti -1c
.RI "void \fBsetMaximum\fP (double max)"
.br
.ti -1c
.RI "double \fBmaximum\fP () const "
.br
.ti -1c
.RI "void \fBsetUpdateInterval\fP (int)"
.br
.RI "\fISpecify the update interval when the wheel is flying\&. \fP"
.ti -1c
.RI "int \fBupdateInterval\fP () const "
.br
.ti -1c
.RI "void \fBsetTracking\fP (bool enable)"
.br
.RI "\fIEn/Disable tracking\&. \fP"
.ti -1c
.RI "bool \fBisTracking\fP () const "
.br
.ti -1c
.RI "double \fBmass\fP () const "
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual void \fBpaintEvent\fP (QPaintEvent *)"
.br
.RI "\fIQt Paint Event\&. \fP"
.ti -1c
.RI "virtual void \fBmousePressEvent\fP (QMouseEvent *)"
.br
.RI "\fIMouse press event handler\&. \fP"
.ti -1c
.RI "virtual void \fBmouseReleaseEvent\fP (QMouseEvent *)"
.br
.RI "\fIMouse Release Event handler\&. \fP"
.ti -1c
.RI "virtual void \fBmouseMoveEvent\fP (QMouseEvent *)"
.br
.RI "\fIMouse Move Event handler\&. \fP"
.ti -1c
.RI "virtual void \fBkeyPressEvent\fP (QKeyEvent *)"
.br
.ti -1c
.RI "virtual void \fBwheelEvent\fP (QWheelEvent *)"
.br
.RI "\fIHandle wheel events\&. \fP"
.ti -1c
.RI "virtual void \fBtimerEvent\fP (QTimerEvent *)"
.br
.RI "\fIQt timer event\&. \fP"
.ti -1c
.RI "void \fBstopFlying\fP ()"
.br
.RI "\fIStop the flying movement of the wheel\&. \fP"
.ti -1c
.RI "QRect \fBwheelRect\fP () const "
.br
.ti -1c
.RI "virtual QSize \fBsizeHint\fP () const "
.br
.ti -1c
.RI "virtual QSize \fBminimumSizeHint\fP () const "
.br
.ti -1c
.RI "virtual void \fBdrawTicks\fP (QPainter *, const QRectF &)"
.br
.ti -1c
.RI "virtual void \fBdrawWheelBackground\fP (QPainter *, const QRectF &)"
.br
.ti -1c
.RI "virtual double \fBvalueAt\fP (const QPoint &) const "
.br
.in -1c
.SH "Detailed Description"
.PP 
The Wheel Widget\&. 

The wheel widget can be used to change values over a very large range in very small steps\&. Using the \fBsetMass()\fP member, it can be configured as a flying wheel\&.
.PP
The default range of the wheel is [0\&.0, 100\&.0]
.PP
\fBSee Also:\fP
.RS 4
The radio example\&. 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "int QwtWheel::borderWidth () const"

.PP
\fBReturns:\fP
.RS 4
Border width 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetBorderWidth()\fP 
.RE
.PP

.SS "void QwtWheel::drawTicks (QPainter *painter, const QRectF &rect)\fC [protected]\fP, \fC [virtual]\fP"
Draw the Wheel's ticks
.PP
\fBParameters:\fP
.RS 4
\fIpainter\fP Painter 
.br
\fIrect\fP Geometry for the wheel 
.RE
.PP

.SS "void QwtWheel::drawWheelBackground (QPainter *painter, const QRectF &rect)\fC [protected]\fP, \fC [virtual]\fP"
Draw the Wheel's background gradient
.PP
\fBParameters:\fP
.RS 4
\fIpainter\fP Painter 
.br
\fIrect\fP Geometry for the wheel 
.RE
.PP

.SS "bool QwtWheel::isInverted () const"

.PP
\fBReturns:\fP
.RS 4
True, when the wheel is inverted 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetInverted()\fP 
.RE
.PP

.SS "bool QwtWheel::isTracking () const"

.PP
\fBReturns:\fP
.RS 4
True, when tracking is enabled 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetTracking()\fP, \fBvalueChanged()\fP, \fBwheelMoved()\fP 
.RE
.PP

.SS "void QwtWheel::keyPressEvent (QKeyEvent *event)\fC [protected]\fP, \fC [virtual]\fP"
Handle key events
.PP
.IP "\(bu" 2
Qt::Key_Home
.br
 Step to \fBminimum()\fP
.IP "\(bu" 2
Qt::Key_End
.br
 Step to \fBmaximum()\fP
.IP "\(bu" 2
Qt::Key_Up
.br
 In case of a horizontal or not inverted vertical wheel the value will be incremented by the step size\&. For an inverted vertical wheel the value will be decremented by the step size\&.
.IP "\(bu" 2
Qt::Key_Down
.br
 In case of a horizontal or not inverted vertical wheel the value will be decremented by the step size\&. For an inverted vertical wheel the value will be incremented by the step size\&.
.IP "\(bu" 2
Qt::Key_PageUp
.br
 The value will be incremented by pageStepSize() * singleStepSize()\&.
.IP "\(bu" 2
Qt::Key_PageDown
.br
 The value will be decremented by pageStepSize() * singleStepSize()\&.
.PP
.PP
\fBParameters:\fP
.RS 4
\fIevent\fP Key event 
.RE
.PP

.SS "double QwtWheel::mass () const"

.PP
\fBReturns:\fP
.RS 4
mass 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetMass()\fP 
.RE
.PP

.SS "double QwtWheel::maximum () const"

.PP
\fBReturns:\fP
.RS 4
The maximum of the range 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetRange()\fP, \fBsetMaximum()\fP, \fBminimum()\fP 
.RE
.PP

.SS "double QwtWheel::minimum () const"

.PP
\fBReturns:\fP
.RS 4
The minimum of the range 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetRange()\fP, \fBsetMinimum()\fP, \fBmaximum()\fP 
.RE
.PP

.SS "QSize QwtWheel::minimumSizeHint () const\fC [protected]\fP, \fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
Minimum size hint 
.RE
.PP
\fBWarning:\fP
.RS 4
The return value is based on the wheel width\&. 
.RE
.PP

.SS "void QwtWheel::mouseMoveEvent (QMouseEvent *event)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Mouse Move Event handler\&. Turn the wheel according to the mouse position
.PP
\fBParameters:\fP
.RS 4
\fIevent\fP Mouse event 
.RE
.PP

.SS "void QwtWheel::mousePressEvent (QMouseEvent *event)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Mouse press event handler\&. Start movement of the wheel\&.
.PP
\fBParameters:\fP
.RS 4
\fIevent\fP Mouse event 
.RE
.PP

.SS "void QwtWheel::mouseReleaseEvent (QMouseEvent *event)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Mouse Release Event handler\&. When the wheel has no mass the movement of the wheel stops, otherwise it starts flying\&.
.PP
\fBParameters:\fP
.RS 4
\fIevent\fP Mouse event 
.RE
.PP

.SS "Qt::Orientation QwtWheel::orientation () const"

.PP
\fBReturns:\fP
.RS 4
Orientation 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetOrientation()\fP 
.RE
.PP

.SS "int QwtWheel::pageStepCount () const"

.PP
\fBReturns:\fP
.RS 4
Page step count 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetPageStepCount()\fP, \fBsingleStep()\fP 
.RE
.PP

.SS "void QwtWheel::paintEvent (QPaintEvent *event)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Qt Paint Event\&. 
.PP
\fBParameters:\fP
.RS 4
\fIevent\fP Paint event 
.RE
.PP

.SS "void QwtWheel::setBorderWidth (intwidth)"

.PP
Set the border width\&. The border defaults to 2\&.
.PP
\fBParameters:\fP
.RS 4
\fIwidth\fP Border width 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBborderWidth()\fP 
.RE
.PP

.SS "void QwtWheel::setInverted (boolon)"

.PP
En/Disable inverted appearance\&. An inverted wheel increases its values in the opposite direction\&. The direction of an inverted horizontal wheel will be from right to left an inverted vertical wheel will increase from bottom to top\&.
.PP
\fBParameters:\fP
.RS 4
\fIon\fP En/Disable inverted appearance 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBisInverted()\fP 
.RE
.PP

.SS "void QwtWheel::setMass (doublemass)\fC [slot]\fP"

.PP
Set the slider's mass for flywheel effect\&. If the slider's mass is greater then 0, it will continue to move after the mouse button has been released\&. Its speed decreases with time at a rate depending on the slider's mass\&. A large mass means that it will continue to move for a long time\&.
.PP
Derived widgets may overload this function to make it public\&.
.PP
\fBParameters:\fP
.RS 4
\fImass\fP New mass in kg
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBmass()\fP 
.RE
.PP

.SS "void QwtWheel::setMaximum (doublevalue)"
Set the maximum value of the range
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP Maximum value 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetRange()\fP, \fBsetMinimum()\fP, \fBmaximum()\fP 
.RE
.PP

.SS "void QwtWheel::setMinimum (doublevalue)"
Set the minimum value of the range
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP Minimum value 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetRange()\fP, \fBsetMaximum()\fP, \fBminimum()\fP
.RE
.PP
\fBNote:\fP
.RS 4
The maximum is adjusted if necessary to ensure that the range remains valid\&. 
.RE
.PP

.SS "void QwtWheel::setOrientation (Qt::Orientationorientation)"

.PP
Set the wheel's orientation\&. The default orientation is Qt::Horizontal\&.
.PP
\fBParameters:\fP
.RS 4
\fIorientation\fP Qt::Horizontal or Qt::Vertical\&. 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBorientation()\fP 
.RE
.PP

.SS "void QwtWheel::setPageStepCount (intcount)"

.PP
Set the page step count\&. pageStepCount is a multiplicator for the single step size that typically corresponds to the user pressing PageUp or PageDown\&.
.PP
A value of 0 disables page stepping\&.
.PP
The default value is 1\&.
.PP
\fBParameters:\fP
.RS 4
\fIcount\fP Multiplicator for the single step size 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBpageStepCount()\fP, \fBsetSingleStep()\fP 
.RE
.PP

.SS "void QwtWheel::setRange (doublemin, doublemax)"

.PP
Set the minimum and maximum values\&. The maximum is adjusted if necessary to ensure that the range remains valid\&. The value might be modified to be inside of the range\&.
.PP
\fBParameters:\fP
.RS 4
\fImin\fP Minimum value 
.br
\fImax\fP Maximum value
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBminimum()\fP, \fBmaximum()\fP 
.RE
.PP

.SS "void QwtWheel::setSingleStep (doublestepSize)"

.PP
Set the step size of the counter\&. A value <= 0\&.0 disables stepping
.PP
\fBParameters:\fP
.RS 4
\fIstepSize\fP Single step size 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsingleStep()\fP, \fBsetPageStepCount()\fP 
.RE
.PP

.SS "void QwtWheel::setStepAlignment (boolon)"

.PP
En/Disable step alignment\&. When step alignment is enabled value changes initiated by user input ( mouse, keyboard, wheel ) are aligned to the multiples of the single step\&.
.PP
\fBParameters:\fP
.RS 4
\fIon\fP On/Off 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBstepAlignment()\fP, \fBsetSingleStep()\fP 
.RE
.PP

.SS "void QwtWheel::setTickCount (intcount)"

.PP
Adjust the number of grooves in the wheel's surface\&. The number of grooves is limited to 6 <= count <= 50\&. Values outside this range will be clipped\&. The default value is 10\&.
.PP
\fBParameters:\fP
.RS 4
\fIcount\fP Number of grooves per 360 degrees 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBtickCount()\fP 
.RE
.PP

.SS "void QwtWheel::setTotalAngle (doubleangle)\fC [slot]\fP"

.PP
Set the total angle which the wheel can be turned\&. One full turn of the wheel corresponds to an angle of 360 degrees\&. A total angle of n*360 degrees means that the wheel has to be turned n times around its axis to get from the minimum value to the maximum value\&.
.PP
The default setting of the total angle is 360 degrees\&.
.PP
\fBParameters:\fP
.RS 4
\fIangle\fP total angle in degrees 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBtotalAngle()\fP 
.RE
.PP

.SS "void QwtWheel::setTracking (boolenable)"

.PP
En/Disable tracking\&. If tracking is enabled (the default), the wheel emits the \fBvalueChanged()\fP signal while the wheel is moving\&. If tracking is disabled, the wheel emits the \fBvalueChanged()\fP signal only when the wheel movement is terminated\&.
.PP
The \fBwheelMoved()\fP signal is emitted regardless id tracking is enabled or not\&.
.PP
\fBParameters:\fP
.RS 4
\fIenable\fP On/Off 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBisTracking()\fP 
.RE
.PP

.SS "void QwtWheel::setUpdateInterval (intinterval)"

.PP
Specify the update interval when the wheel is flying\&. Default and minimum value is 50 ms\&.
.PP
\fBParameters:\fP
.RS 4
\fIinterval\fP Interval in milliseconds 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBupdateInterval()\fP, \fBsetMass()\fP, \fBsetTracking()\fP 
.RE
.PP

.SS "void QwtWheel::setValue (doublevalue)\fC [slot]\fP"

.PP
Set a new value without adjusting to the step raster\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP New value
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBvalue()\fP, \fBvalueChanged()\fP 
.RE
.PP
\fBWarning:\fP
.RS 4
The value is clipped when it lies outside the range\&. 
.RE
.PP

.SS "void QwtWheel::setViewAngle (doubleangle)\fC [slot]\fP"

.PP
Specify the visible portion of the wheel\&. You may use this function for fine-tuning the appearance of the wheel\&. The default value is 175 degrees\&. The value is limited from 10 to 175 degrees\&.
.PP
\fBParameters:\fP
.RS 4
\fIangle\fP Visible angle in degrees 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBviewAngle()\fP, \fBsetTotalAngle()\fP 
.RE
.PP

.SS "void QwtWheel::setWheelBorderWidth (intborderWidth)"

.PP
Set the wheel border width of the wheel\&. The wheel border must not be smaller than 1 and is limited in dependence on the wheel's size\&. Values outside the allowed range will be clipped\&.
.PP
The wheel border defaults to 2\&.
.PP
\fBParameters:\fP
.RS 4
\fIborderWidth\fP Border width 
.RE
.PP
\fBSee Also:\fP
.RS 4
internalBorder() 
.RE
.PP

.SS "void QwtWheel::setWheelWidth (intwidth)"

.PP
Set the width of the wheel\&. Corresponds to the wheel height for horizontal orientation, and the wheel width for vertical orientation\&.
.PP
\fBParameters:\fP
.RS 4
\fIwidth\fP the wheel's width 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBwheelWidth()\fP 
.RE
.PP

.SS "void QwtWheel::setWrapping (boolon)"

.PP
En/Disable wrapping\&. If wrapping is true stepping up from \fBmaximum()\fP value will take you to the \fBminimum()\fP value and vice versa\&.
.PP
\fBParameters:\fP
.RS 4
\fIon\fP En/Disable wrapping 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBwrapping()\fP 
.RE
.PP

.SS "double QwtWheel::singleStep () const"

.PP
\fBReturns:\fP
.RS 4
Single step size 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetSingleStep()\fP 
.RE
.PP

.SS "QSize QwtWheel::sizeHint () const\fC [protected]\fP, \fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
a size hint 
.RE
.PP

.SS "bool QwtWheel::stepAlignment () const"

.PP
\fBReturns:\fP
.RS 4
True, when the step alignment is enabled 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetStepAlignment()\fP, \fBsingleStep()\fP 
.RE
.PP

.SS "int QwtWheel::tickCount () const"

.PP
\fBReturns:\fP
.RS 4
Number of grooves in the wheel's surface\&. 
.RE
.PP
\fBSee Also:\fP
.RS 4
setTickCnt() 
.RE
.PP

.SS "void QwtWheel::timerEvent (QTimerEvent *event)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Qt timer event\&. The flying wheel effect is implemented using a timer
.PP
\fBParameters:\fP
.RS 4
\fIevent\fP Timer event
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBupdateInterval()\fP 
.RE
.PP

.SS "double QwtWheel::totalAngle () const"

.PP
\fBReturns:\fP
.RS 4
Total angle which the wheel can be turned\&. 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetTotalAngle()\fP 
.RE
.PP

.SS "int QwtWheel::updateInterval () const"

.PP
\fBReturns:\fP
.RS 4
Update interval when the wheel is flying 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetUpdateInterval()\fP, \fBmass()\fP, \fBisTracking()\fP 
.RE
.PP

.SS "double QwtWheel::value () const"

.PP
\fBReturns:\fP
.RS 4
Current value of the wheel 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetValue()\fP, \fBvalueChanged()\fP 
.RE
.PP

.SS "double QwtWheel::valueAt (const QPoint &pos) const\fC [protected]\fP, \fC [virtual]\fP"
Determine the value corresponding to a specified point
.PP
\fBParameters:\fP
.RS 4
\fIpos\fP Position 
.RE
.PP
\fBReturns:\fP
.RS 4
Value corresponding to pos 
.RE
.PP

.SS "void QwtWheel::valueChanged (doublevalue)\fC [signal]\fP"

.PP
Notify a change of value\&. When tracking is enabled this signal will be emitted every time the value changes\&.
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP new value 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetTracking()\fP 
.RE
.PP

.SS "double QwtWheel::viewAngle () const"

.PP
\fBReturns:\fP
.RS 4
Visible portion of the wheel 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetViewAngle()\fP, \fBtotalAngle()\fP 
.RE
.PP

.SS "int QwtWheel::wheelBorderWidth () const"

.PP
\fBReturns:\fP
.RS 4
Wheel border width 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetWheelBorderWidth()\fP 
.RE
.PP

.SS "void QwtWheel::wheelEvent (QWheelEvent *event)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Handle wheel events\&. In/Decrement the value
.PP
\fBParameters:\fP
.RS 4
\fIevent\fP Wheel event 
.RE
.PP

.SS "void QwtWheel::wheelMoved (doublevalue)\fC [signal]\fP"
This signal is emitted when the user moves the wheel with the mouse\&.
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP new value 
.RE
.PP

.SS "void QwtWheel::wheelPressed ()\fC [signal]\fP"
This signal is emitted when the user presses the the wheel with the mouse 
.SS "QRect QwtWheel::wheelRect () const\fC [protected]\fP"

.PP
\fBReturns:\fP
.RS 4
Rectangle of the wheel without the outer border 
.RE
.PP

.SS "void QwtWheel::wheelReleased ()\fC [signal]\fP"
This signal is emitted when the user releases the mouse 
.SS "int QwtWheel::wheelWidth () const"

.PP
\fBReturns:\fP
.RS 4
Width of the wheel 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetWheelWidth()\fP 
.RE
.PP

.SS "bool QwtWheel::wrapping () const"

.PP
\fBReturns:\fP
.RS 4
True, when wrapping is set 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetWrapping()\fP 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for Qwt User's Guide from the source code\&.
