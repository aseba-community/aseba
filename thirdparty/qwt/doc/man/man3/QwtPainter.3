.TH "QwtPainter" 3 "Thu Dec 11 2014" "Version 6.1.2" "Qwt User's Guide" \" -*- nroff -*-
.ad l
.nh
.SH NAME
QwtPainter \- 
.PP
A collection of QPainter workarounds\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <qwt_painter\&.h>\fP
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static void \fBsetPolylineSplitting\fP (bool)"
.br
.RI "\fIEn/Disable line splitting for the raster paint engine\&. \fP"
.ti -1c
.RI "static bool \fBpolylineSplitting\fP ()"
.br
.ti -1c
.RI "static void \fBsetRoundingAlignment\fP (bool)"
.br
.ti -1c
.RI "static bool \fBroundingAlignment\fP ()"
.br
.ti -1c
.RI "static bool \fBroundingAlignment\fP (QPainter *)"
.br
.ti -1c
.RI "static void \fBdrawText\fP (QPainter *, double x, double y, const QString &)"
.br
.RI "\fIWrapper for QPainter::drawText() \fP"
.ti -1c
.RI "static void \fBdrawText\fP (QPainter *, const QPointF &, const QString &)"
.br
.RI "\fIWrapper for QPainter::drawText() \fP"
.ti -1c
.RI "static void \fBdrawText\fP (QPainter *, double x, double y, double w, double h, int flags, const QString &)"
.br
.RI "\fIWrapper for QPainter::drawText() \fP"
.ti -1c
.RI "static void \fBdrawText\fP (QPainter *, const QRectF &, int flags, const QString &)"
.br
.RI "\fIWrapper for QPainter::drawText() \fP"
.ti -1c
.RI "static void \fBdrawSimpleRichText\fP (QPainter *, const QRectF &, int flags, const QTextDocument &)"
.br
.ti -1c
.RI "static void \fBdrawRect\fP (QPainter *, double x, double y, double w, double h)"
.br
.RI "\fIWrapper for QPainter::drawRect() \fP"
.ti -1c
.RI "static void \fBdrawRect\fP (QPainter *, const QRectF &rect)"
.br
.RI "\fIWrapper for QPainter::drawRect() \fP"
.ti -1c
.RI "static void \fBfillRect\fP (QPainter *, const QRectF &, const QBrush &)"
.br
.RI "\fIWrapper for QPainter::fillRect() \fP"
.ti -1c
.RI "static void \fBdrawEllipse\fP (QPainter *, const QRectF &)"
.br
.RI "\fIWrapper for QPainter::drawEllipse() \fP"
.ti -1c
.RI "static void \fBdrawPie\fP (QPainter *, const QRectF &r, int a, int alen)"
.br
.RI "\fIWrapper for QPainter::drawPie() \fP"
.ti -1c
.RI "static void \fBdrawLine\fP (QPainter *, double x1, double y1, double x2, double y2)"
.br
.RI "\fIWrapper for QPainter::drawLine() \fP"
.ti -1c
.RI "static void \fBdrawLine\fP (QPainter *, const QPointF &p1, const QPointF &p2)"
.br
.RI "\fIWrapper for QPainter::drawLine() \fP"
.ti -1c
.RI "static void \fBdrawLine\fP (QPainter *, const QLineF &)"
.br
.RI "\fIWrapper for QPainter::drawLine() \fP"
.ti -1c
.RI "static void \fBdrawPolygon\fP (QPainter *, const QPolygonF &)"
.br
.RI "\fIWrapper for QPainter::drawPolygon() \fP"
.ti -1c
.RI "static void \fBdrawPolyline\fP (QPainter *, const QPolygonF &)"
.br
.RI "\fIWrapper for QPainter::drawPolyline() \fP"
.ti -1c
.RI "static void \fBdrawPolyline\fP (QPainter *, const QPointF *, int pointCount)"
.br
.RI "\fIWrapper for QPainter::drawPolyline() \fP"
.ti -1c
.RI "static void \fBdrawPolygon\fP (QPainter *, const QPolygon &)"
.br
.RI "\fIWrapper for QPainter::drawPolygon() \fP"
.ti -1c
.RI "static void \fBdrawPolyline\fP (QPainter *, const QPolygon &)"
.br
.RI "\fIWrapper for QPainter::drawPolyline() \fP"
.ti -1c
.RI "static void \fBdrawPolyline\fP (QPainter *, const QPoint *, int pointCount)"
.br
.RI "\fIWrapper for QPainter::drawPolyline() \fP"
.ti -1c
.RI "static void \fBdrawPoint\fP (QPainter *, const QPoint &)"
.br
.RI "\fIWrapper for QPainter::drawPoint() \fP"
.ti -1c
.RI "static void \fBdrawPoints\fP (QPainter *, const QPolygon &)"
.br
.RI "\fIWrapper for QPainter::drawPoints() \fP"
.ti -1c
.RI "static void \fBdrawPoints\fP (QPainter *, const QPoint *, int pointCount)"
.br
.RI "\fIWrapper for QPainter::drawPoints() \fP"
.ti -1c
.RI "static void \fBdrawPoint\fP (QPainter *, double x, double y)"
.br
.RI "\fIWrapper for QPainter::drawPoint() \fP"
.ti -1c
.RI "static void \fBdrawPoint\fP (QPainter *, const QPointF &)"
.br
.RI "\fIWrapper for QPainter::drawPoint() \fP"
.ti -1c
.RI "static void \fBdrawPoints\fP (QPainter *, const QPolygonF &)"
.br
.RI "\fIWrapper for QPainter::drawPoints() \fP"
.ti -1c
.RI "static void \fBdrawPoints\fP (QPainter *, const QPointF *, int pointCount)"
.br
.RI "\fIWrapper for QPainter::drawPoints() \fP"
.ti -1c
.RI "static void \fBdrawPath\fP (QPainter *, const QPainterPath &)"
.br
.RI "\fIWrapper for QPainter::drawPath() \fP"
.ti -1c
.RI "static void \fBdrawImage\fP (QPainter *, const QRectF &, const QImage &)"
.br
.RI "\fIWrapper for QPainter::drawImage() \fP"
.ti -1c
.RI "static void \fBdrawPixmap\fP (QPainter *, const QRectF &, const QPixmap &)"
.br
.RI "\fIWrapper for QPainter::drawPixmap() \fP"
.ti -1c
.RI "static void \fBdrawRoundFrame\fP (QPainter *, const QRectF &, const QPalette &, int lineWidth, int frameStyle)"
.br
.ti -1c
.RI "static void \fBdrawRoundedFrame\fP (QPainter *, const QRectF &, double xRadius, double yRadius, const QPalette &, int lineWidth, int frameStyle)"
.br
.ti -1c
.RI "static void \fBdrawFrame\fP (QPainter *, const QRectF &rect, const QPalette &palette, QPalette::ColorRole foregroundRole, int lineWidth, int midLineWidth, int frameStyle)"
.br
.ti -1c
.RI "static void \fBdrawFocusRect\fP (QPainter *, const QWidget *)"
.br
.RI "\fIDraw a focus rectangle on a widget using its style\&. \fP"
.ti -1c
.RI "static void \fBdrawFocusRect\fP (QPainter *, const QWidget *, const QRect &)"
.br
.RI "\fIDraw a focus rectangle on a widget using its style\&. \fP"
.ti -1c
.RI "static void \fBdrawColorBar\fP (QPainter *painter, const \fBQwtColorMap\fP &, const \fBQwtInterval\fP &, const \fBQwtScaleMap\fP &, Qt::Orientation, const QRectF &)"
.br
.ti -1c
.RI "static bool \fBisAligning\fP (QPainter *painter)"
.br
.ti -1c
.RI "static bool \fBisX11GraphicsSystem\fP ()"
.br
.ti -1c
.RI "static void \fBfillPixmap\fP (const QWidget *, QPixmap &, const QPoint &offset=QPoint())"
.br
.ti -1c
.RI "static void \fBdrawBackgound\fP (QPainter *painter, const QRectF &rect, const QWidget *widget)"
.br
.ti -1c
.RI "static QPixmap \fBbackingStore\fP (QWidget *, const QSize &)"
.br
.in -1c
.SH "Detailed Description"
.PP 
A collection of QPainter workarounds\&. 
.SH "Member Function Documentation"
.PP 
.SS "QPixmap QwtPainter::backingStore (QWidget *widget, const QSize &size)\fC [static]\fP"

.PP
\fBReturns:\fP
.RS 4
A pixmap that can be used as backing store
.RE
.PP
\fBParameters:\fP
.RS 4
\fIwidget\fP Widget, for which the backinstore is intended 
.br
\fIsize\fP Size of the pixmap 
.RE
.PP

.SS "void QwtPainter::drawBackgound (QPainter *painter, const QRectF &rect, const QWidget *widget)\fC [static]\fP"
Fill rect with the background of a widget
.PP
\fBParameters:\fP
.RS 4
\fIpainter\fP Painter 
.br
\fIrect\fP Rectangle to be filled 
.br
\fIwidget\fP Widget
.RE
.PP
\fBSee Also:\fP
.RS 4
QStyle::PE_Widget, QWidget::backgroundRole() 
.RE
.PP

.SS "void QwtPainter::drawColorBar (QPainter *painter, const \fBQwtColorMap\fP &colorMap, const \fBQwtInterval\fP &interval, const \fBQwtScaleMap\fP &scaleMap, Qt::Orientationorientation, const QRectF &rect)\fC [static]\fP"
Draw a color bar into a rectangle
.PP
\fBParameters:\fP
.RS 4
\fIpainter\fP Painter 
.br
\fIcolorMap\fP Color map 
.br
\fIinterval\fP Value range 
.br
\fIscaleMap\fP Scale map 
.br
\fIorientation\fP Orientation 
.br
\fIrect\fP Traget rectangle 
.RE
.PP

.SS "void QwtPainter::drawFrame (QPainter *painter, const QRectF &rect, const QPalette &palette, QPalette::ColorRoleforegroundRole, intframeWidth, intmidLineWidth, intframeStyle)\fC [static]\fP"
Draw a rectangular frame
.PP
\fBParameters:\fP
.RS 4
\fIpainter\fP Painter 
.br
\fIrect\fP Frame rectangle 
.br
\fIpalette\fP Palette 
.br
\fIforegroundRole\fP Foreground role used for QFrame::Plain 
.br
\fIframeWidth\fP Frame width 
.br
\fImidLineWidth\fP Used for QFrame::Box 
.br
\fIframeStyle\fP bitwise OR´ed value of QFrame::Shape and QFrame::Shadow 
.RE
.PP

.SS "void QwtPainter::drawRoundedFrame (QPainter *painter, const QRectF &rect, doublexRadius, doubleyRadius, const QPalette &palette, intlineWidth, intframeStyle)\fC [static]\fP"
Draw a rectangular frame with rounded borders
.PP
\fBParameters:\fP
.RS 4
\fIpainter\fP Painter 
.br
\fIrect\fP Frame rectangle 
.br
\fIxRadius\fP x-radius of the ellipses defining the corners 
.br
\fIyRadius\fP y-radius of the ellipses defining the corners 
.br
\fIpalette\fP QPalette::WindowText is used for plain borders QPalette::Dark and QPalette::Light for raised or sunken borders 
.br
\fIlineWidth\fP Line width 
.br
\fIframeStyle\fP bitwise OR´ed value of QFrame::Shape and QFrame::Shadow 
.RE
.PP

.SS "void QwtPainter::drawRoundFrame (QPainter *painter, const QRectF &rect, const QPalette &palette, intlineWidth, intframeStyle)\fC [static]\fP"
Draw a round frame
.PP
\fBParameters:\fP
.RS 4
\fIpainter\fP Painter 
.br
\fIrect\fP Frame rectangle 
.br
\fIpalette\fP QPalette::WindowText is used for plain borders QPalette::Dark and QPalette::Light for raised or sunken borders 
.br
\fIlineWidth\fP Line width 
.br
\fIframeStyle\fP bitwise OR´ed value of QFrame::Shape and QFrame::Shadow 
.RE
.PP

.SS "void QwtPainter::drawSimpleRichText (QPainter *painter, const QRectF &rect, intflags, const QTextDocument &text)\fC [static]\fP"
Draw a text document into a rectangle
.PP
\fBParameters:\fP
.RS 4
\fIpainter\fP Painter 
.br
\fIrect\fP Traget rectangle 
.br
\fIflags\fP Alignments/Text flags, see QPainter::drawText() 
.br
\fItext\fP Text document 
.RE
.PP

.SS "void QwtPainter::fillPixmap (const QWidget *widget, QPixmap &pixmap, const QPoint &offset = \fCQPoint()\fP)\fC [static]\fP"
Fill a pixmap with the content of a widget
.PP
In Qt >= 5\&.0 QPixmap::fill() is a nop, in Qt 4\&.x it is buggy for backgrounds with gradients\&. Thus \fBfillPixmap()\fP offers an alternative implementation\&.
.PP
\fBParameters:\fP
.RS 4
\fIwidget\fP Widget 
.br
\fIpixmap\fP Pixmap to be filled 
.br
\fIoffset\fP Offset
.RE
.PP
\fBSee Also:\fP
.RS 4
QPixmap::fill() 
.RE
.PP

.SS "bool QwtPainter::isAligning (QPainter *painter)\fC [static]\fP"
Check if the painter is using a paint engine, that aligns coordinates to integers\&. Today these are all paint engines beside QPaintEngine::Pdf and QPaintEngine::SVG\&.
.PP
If we have an integer based paint engine it is also checked if the painter has a transformation matrix, that rotates or scales\&.
.PP
\fBParameters:\fP
.RS 4
\fIpainter\fP Painter 
.RE
.PP
\fBReturns:\fP
.RS 4
true, when the painter is aligning
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetRoundingAlignment()\fP 
.RE
.PP

.SS "bool QwtPainter::isX11GraphicsSystem ()\fC [static]\fP"
Check is the application is running with the X11 graphics system that has some special capabilities that can be used for incremental painting to a widget\&.
.PP
\fBReturns:\fP
.RS 4
True, when the graphics system is X11 
.RE
.PP

.SS "bool QwtPainter::polylineSplitting ()\fC [inline]\fP, \fC [static]\fP"

.PP
\fBReturns:\fP
.RS 4
True, when line splitting for the raster paint engine is enabled\&. 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetPolylineSplitting()\fP 
.RE
.PP

.SS "bool QwtPainter::roundingAlignment ()\fC [inline]\fP, \fC [static]\fP"
Check whether coordinates should be rounded, before they are painted to a paint engine that rounds to integer values\&. For other paint engines ( PDF, SVG ), this flag has no effect\&.
.PP
\fBReturns:\fP
.RS 4
True, when rounding is enabled 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetRoundingAlignment()\fP, \fBisAligning()\fP 
.RE
.PP

.SS "bool QwtPainter::roundingAlignment (QPainter *painter)\fC [inline]\fP, \fC [static]\fP"

.PP
\fBReturns:\fP
.RS 4
\fBroundingAlignment()\fP && isAligning(painter); 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIpainter\fP Painter 
.RE
.PP

.SS "void QwtPainter::setPolylineSplitting (boolenable)\fC [static]\fP"

.PP
En/Disable line splitting for the raster paint engine\&. In some Qt versions the raster paint engine paints polylines of many points much faster when they are split in smaller chunks: f\&.e all supported Qt versions >= Qt 5\&.0 when drawing an antialiased polyline with a pen width >=2\&.
.PP
The default setting is true\&.
.PP
\fBSee Also:\fP
.RS 4
\fBpolylineSplitting()\fP 
.RE
.PP

.SS "void QwtPainter::setRoundingAlignment (boolenable)\fC [static]\fP"
Enable whether coordinates should be rounded, before they are painted to a paint engine that floors to integer values\&. For other paint engines this ( PDF, SVG ), this flag has no effect\&. \fBQwtPainter\fP stores this flag only, the rounding itself is done in the painting code ( f\&.e the plot items )\&.
.PP
The default setting is true\&.
.PP
\fBSee Also:\fP
.RS 4
\fBroundingAlignment()\fP, \fBisAligning()\fP 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for Qwt User's Guide from the source code\&.
