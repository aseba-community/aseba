.TH "QwtCounter" 3 "Thu Dec 11 2014" "Version 6.1.2" "Qwt User's Guide" \" -*- nroff -*-
.ad l
.nh
.SH NAME
QwtCounter \- 
.PP
The Counter Widget\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <qwt_counter\&.h>\fP
.PP
Inherits QWidget\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum \fBButton\fP { \fBButton1\fP, \fBButton2\fP, \fBButton3\fP, \fBButtonCnt\fP }"
.br
.RI "\fIButton index\&. \fP"
.in -1c
.SS "Public Slots"

.in +1c
.ti -1c
.RI "void \fBsetValue\fP (double)"
.br
.RI "\fISet a new value without adjusting to the step raster\&. \fP"
.in -1c
.SS "Signals"

.in +1c
.ti -1c
.RI "void \fBbuttonReleased\fP (double \fBvalue\fP)"
.br
.ti -1c
.RI "void \fBvalueChanged\fP (double \fBvalue\fP)"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBQwtCounter\fP (QWidget *parent=NULL)"
.br
.ti -1c
.RI "virtual \fB~QwtCounter\fP ()"
.br
.RI "\fIDestructor\&. \fP"
.ti -1c
.RI "void \fBsetValid\fP (bool)"
.br
.ti -1c
.RI "bool \fBisValid\fP () const "
.br
.ti -1c
.RI "void \fBsetWrapping\fP (bool)"
.br
.RI "\fIEn/Disable wrapping\&. \fP"
.ti -1c
.RI "bool \fBwrapping\fP () const "
.br
.ti -1c
.RI "bool \fBisReadOnly\fP () const "
.br
.ti -1c
.RI "void \fBsetReadOnly\fP (bool)"
.br
.RI "\fIAllow/disallow the user to manually edit the value\&. \fP"
.ti -1c
.RI "void \fBsetNumButtons\fP (int n)"
.br
.ti -1c
.RI "int \fBnumButtons\fP () const "
.br
.ti -1c
.RI "void \fBsetIncSteps\fP (\fBQwtCounter::Button\fP btn, int nSteps)"
.br
.ti -1c
.RI "int \fBincSteps\fP (\fBQwtCounter::Button\fP btn) const "
.br
.ti -1c
.RI "virtual QSize \fBsizeHint\fP () const "
.br
.RI "\fIA size hint\&. \fP"
.ti -1c
.RI "double \fBsingleStep\fP () const "
.br
.ti -1c
.RI "void \fBsetSingleStep\fP (double s)"
.br
.RI "\fISet the step size of the counter\&. \fP"
.ti -1c
.RI "void \fBsetRange\fP (double min, double max)"
.br
.RI "\fISet the minimum and maximum values\&. \fP"
.ti -1c
.RI "double \fBminimum\fP () const "
.br
.ti -1c
.RI "void \fBsetMinimum\fP (double min)"
.br
.ti -1c
.RI "double \fBmaximum\fP () const "
.br
.ti -1c
.RI "void \fBsetMaximum\fP (double max)"
.br
.ti -1c
.RI "void \fBsetStepButton1\fP (int nSteps)"
.br
.ti -1c
.RI "int \fBstepButton1\fP () const "
.br
.RI "\fIreturns the number of increment steps for button 1 \fP"
.ti -1c
.RI "void \fBsetStepButton2\fP (int nSteps)"
.br
.ti -1c
.RI "int \fBstepButton2\fP () const "
.br
.RI "\fIreturns the number of increment steps for button 2 \fP"
.ti -1c
.RI "void \fBsetStepButton3\fP (int nSteps)"
.br
.ti -1c
.RI "int \fBstepButton3\fP () const "
.br
.RI "\fIreturns the number of increment steps for button 3 \fP"
.ti -1c
.RI "double \fBvalue\fP () const "
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual bool \fBevent\fP (QEvent *)"
.br
.ti -1c
.RI "virtual void \fBwheelEvent\fP (QWheelEvent *)"
.br
.ti -1c
.RI "virtual void \fBkeyPressEvent\fP (QKeyEvent *)"
.br
.in -1c
.SH "Detailed Description"
.PP 
The Counter Widget\&. 

A Counter consists of a label displaying a number and one ore more (up to three) push buttons on each side of the label which can be used to increment or decrement the counter's value\&.
.PP
A counter has a range from a minimum value to a maximum value and a step size\&. When the wrapping property is set the counter is circular\&.
.PP
The number of steps by which a button increments or decrements the value can be specified using \fBsetIncSteps()\fP\&. The number of buttons can be changed with \fBsetNumButtons()\fP\&.
.PP
Example: 
.PP
.nf
#include <qwt_counter\&.h>

QwtCounter *counter = new QwtCounter(parent);

counter->setRange(0\&.0, 100\&.0);                  // From 0\&.0 to 100
counter->setSingleStep( 1\&.0 );                  // Step size 1\&.0
counter->setNumButtons(2);                      // Two buttons each side
counter->setIncSteps(QwtCounter::Button1, 1);   // Button 1 increments 1 step
counter->setIncSteps(QwtCounter::Button2, 20);  // Button 2 increments 20 steps

connect(counter, SIGNAL(valueChanged(double)), myClass, SLOT(newValue(double)));

.fi
.PP
 
.SH "Member Enumeration Documentation"
.PP 
.SS "enum \fBQwtCounter::Button\fP"

.PP
Button index\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIButton1 \fP\fP
Button intended for minor steps\&. 
.TP
\fB\fIButton2 \fP\fP
Button intended for medium steps\&. 
.TP
\fB\fIButton3 \fP\fP
Button intended for large steps\&. 
.TP
\fB\fIButtonCnt \fP\fP
Number of buttons\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "QwtCounter::QwtCounter (QWidget *parent = \fCNULL\fP)\fC [explicit]\fP"
The counter is initialized with a range is set to [0\&.0, 1\&.0] with 0\&.01 as single step size\&. The value is invalid\&.
.PP
The default number of buttons is set to 2\&. The default increments are: 
.PD 0

.IP "\(bu" 2
Button 1: 1 step 
.IP "\(bu" 2
Button 2: 10 steps 
.IP "\(bu" 2
Button 3: 100 steps
.PP
\fBParameters:\fP
.RS 4
\fIparent\fP 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "void QwtCounter::buttonReleased (doublevalue)\fC [signal]\fP"
This signal is emitted when a button has been released 
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP The new value 
.RE
.PP

.SS "bool QwtCounter::event (QEvent *event)\fC [protected]\fP, \fC [virtual]\fP"
Handle QEvent::PolishRequest events 
.PP
\fBParameters:\fP
.RS 4
\fIevent\fP Event 
.RE
.PP
\fBReturns:\fP
.RS 4
see QWidget::event() 
.RE
.PP

.SS "int QwtCounter::incSteps (\fBQwtCounter::Button\fPbutton) const"

.PP
\fBReturns:\fP
.RS 4
The number of steps by which a specified button increments the value or 0 if the button is invalid\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIbutton\fP Button index
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetIncSteps()\fP 
.RE
.PP

.SS "bool QwtCounter::isReadOnly () const"

.PP
\fBReturns:\fP
.RS 4
True, when the line line edit is read only\&. (default is no) 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetReadOnly()\fP 
.RE
.PP

.SS "bool QwtCounter::isValid () const"

.PP
\fBReturns:\fP
.RS 4
True, if the value is valid 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetValid()\fP, \fBsetValue()\fP 
.RE
.PP

.SS "void QwtCounter::keyPressEvent (QKeyEvent *event)\fC [protected]\fP, \fC [virtual]\fP"
Handle key events
.PP
.IP "\(bu" 2
Ctrl + Qt::Key_Home
.br
 Step to \fBminimum()\fP
.IP "\(bu" 2
Ctrl + Qt::Key_End
.br
 Step to \fBmaximum()\fP
.IP "\(bu" 2
Qt::Key_Up
.br
 Increment by incSteps(QwtCounter::Button1)
.IP "\(bu" 2
Qt::Key_Down
.br
 Decrement by incSteps(QwtCounter::Button1)
.IP "\(bu" 2
Qt::Key_PageUp
.br
 Increment by incSteps(QwtCounter::Button2)
.IP "\(bu" 2
Qt::Key_PageDown
.br
 Decrement by incSteps(QwtCounter::Button2)
.IP "\(bu" 2
Shift + Qt::Key_PageUp
.br
 Increment by incSteps(QwtCounter::Button3)
.IP "\(bu" 2
Shift + Qt::Key_PageDown
.br
 Decrement by incSteps(QwtCounter::Button3)
.PP
.PP
\fBParameters:\fP
.RS 4
\fIevent\fP Key event 
.RE
.PP

.SS "double QwtCounter::maximum () const"

.PP
\fBReturns:\fP
.RS 4
The maximum of the range 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetRange()\fP, \fBsetMaximum()\fP, \fBminimum()\fP 
.RE
.PP

.SS "double QwtCounter::minimum () const"

.PP
\fBReturns:\fP
.RS 4
The minimum of the range 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetRange()\fP, \fBsetMinimum()\fP, \fBmaximum()\fP 
.RE
.PP

.SS "int QwtCounter::numButtons () const"

.PP
\fBReturns:\fP
.RS 4
The number of buttons on each side of the widget\&. 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetNumButtons()\fP 
.RE
.PP

.SS "void QwtCounter::setIncSteps (\fBQwtCounter::Button\fPbutton, intnumSteps)"
Specify the number of steps by which the value is incremented or decremented when a specified button is pushed\&.
.PP
\fBParameters:\fP
.RS 4
\fIbutton\fP Button index 
.br
\fInumSteps\fP Number of steps
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBincSteps()\fP 
.RE
.PP

.SS "void QwtCounter::setMaximum (doublevalue)"
Set the maximum value of the range
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP Maximum value 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetRange()\fP, \fBsetMinimum()\fP, \fBmaximum()\fP 
.RE
.PP

.SS "void QwtCounter::setMinimum (doublevalue)"
Set the minimum value of the range
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP Minimum value 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetRange()\fP, \fBsetMaximum()\fP, \fBminimum()\fP
.RE
.PP
\fBNote:\fP
.RS 4
The maximum is adjusted if necessary to ensure that the range remains valid\&. 
.RE
.PP

.SS "void QwtCounter::setNumButtons (intnumButtons)"
Specify the number of buttons on each side of the label
.PP
\fBParameters:\fP
.RS 4
\fInumButtons\fP Number of buttons 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBnumButtons()\fP 
.RE
.PP

.SS "void QwtCounter::setRange (doublemin, doublemax)"

.PP
Set the minimum and maximum values\&. The maximum is adjusted if necessary to ensure that the range remains valid\&. The value might be modified to be inside of the range\&.
.PP
\fBParameters:\fP
.RS 4
\fImin\fP Minimum value 
.br
\fImax\fP Maximum value
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBminimum()\fP, \fBmaximum()\fP 
.RE
.PP

.SS "void QwtCounter::setReadOnly (boolon)"

.PP
Allow/disallow the user to manually edit the value\&. 
.PP
\fBParameters:\fP
.RS 4
\fIon\fP True disable editing 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBisReadOnly()\fP 
.RE
.PP

.SS "void QwtCounter::setSingleStep (doublestepSize)"

.PP
Set the step size of the counter\&. A value <= 0\&.0 disables stepping
.PP
\fBParameters:\fP
.RS 4
\fIstepSize\fP Single step size 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsingleStep()\fP 
.RE
.PP

.SS "void QwtCounter::setStepButton1 (intnSteps)"
Set the number of increment steps for button 1 
.PP
\fBParameters:\fP
.RS 4
\fInSteps\fP Number of steps 
.RE
.PP

.SS "void QwtCounter::setStepButton2 (intnSteps)"
Set the number of increment steps for button 2 
.PP
\fBParameters:\fP
.RS 4
\fInSteps\fP Number of steps 
.RE
.PP

.SS "void QwtCounter::setStepButton3 (intnSteps)"
Set the number of increment steps for button 3 
.PP
\fBParameters:\fP
.RS 4
\fInSteps\fP Number of steps 
.RE
.PP

.SS "void QwtCounter::setValid (boolon)"
Set the counter to be in valid/invalid state
.PP
When the counter is set to invalid, no numbers are displayed and the buttons are disabled\&.
.PP
\fBParameters:\fP
.RS 4
\fIon\fP If true the counter will be set as valid
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetValue()\fP, \fBisValid()\fP 
.RE
.PP

.SS "void QwtCounter::setValue (doublevalue)\fC [slot]\fP"

.PP
Set a new value without adjusting to the step raster\&. The state of the counter is set to be valid\&.
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP New value
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBisValid()\fP, \fBvalue()\fP, \fBvalueChanged()\fP 
.RE
.PP
\fBWarning:\fP
.RS 4
The value is clipped when it lies outside the range\&. 
.RE
.PP

.SS "void QwtCounter::setWrapping (boolon)"

.PP
En/Disable wrapping\&. If wrapping is true stepping up from \fBmaximum()\fP value will take you to the \fBminimum()\fP value and vice versa\&.
.PP
\fBParameters:\fP
.RS 4
\fIon\fP En/Disable wrapping 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBwrapping()\fP 
.RE
.PP

.SS "double QwtCounter::singleStep () const"

.PP
\fBReturns:\fP
.RS 4
Single step size 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetSingleStep()\fP 
.RE
.PP

.SS "double QwtCounter::value () const"

.PP
\fBReturns:\fP
.RS 4
Current value of the counter 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetValue()\fP, \fBvalueChanged()\fP 
.RE
.PP

.SS "void QwtCounter::valueChanged (doublevalue)\fC [signal]\fP"
This signal is emitted when the counter's value has changed 
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP The new value 
.RE
.PP

.SS "void QwtCounter::wheelEvent (QWheelEvent *event)\fC [protected]\fP, \fC [virtual]\fP"
Handle wheel events 
.PP
\fBParameters:\fP
.RS 4
\fIevent\fP Wheel event 
.RE
.PP

.SS "bool QwtCounter::wrapping () const"

.PP
\fBReturns:\fP
.RS 4
True, when wrapping is set 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetWrapping()\fP 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for Qwt User's Guide from the source code\&.
