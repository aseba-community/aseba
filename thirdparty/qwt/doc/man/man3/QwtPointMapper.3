.TH "QwtPointMapper" 3 "Thu Dec 11 2014" "Version 6.1.2" "Qwt User's Guide" \" -*- nroff -*-
.ad l
.nh
.SH NAME
QwtPointMapper \- 
.PP
A helper class for translating a series of points\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <qwt_point_mapper\&.h>\fP
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum \fBTransformationFlag\fP { \fBRoundPoints\fP = 0x01, \fBWeedOutPoints\fP = 0x02 }"
.br
.RI "\fIFlags affecting the transformation process\&. \fP"
.ti -1c
.RI "typedef QFlags
.br
< \fBTransformationFlag\fP > \fBTransformationFlags\fP"
.br
.RI "\fIFlags affecting the transformation process\&. \fP"
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBQwtPointMapper\fP ()"
.br
.RI "\fIConstructor\&. \fP"
.ti -1c
.RI "\fB~QwtPointMapper\fP ()"
.br
.RI "\fIDestructor\&. \fP"
.ti -1c
.RI "void \fBsetFlags\fP (\fBTransformationFlags\fP)"
.br
.ti -1c
.RI "\fBTransformationFlags\fP \fBflags\fP () const "
.br
.ti -1c
.RI "void \fBsetFlag\fP (\fBTransformationFlag\fP, bool on=true)"
.br
.ti -1c
.RI "bool \fBtestFlag\fP (\fBTransformationFlag\fP) const "
.br
.ti -1c
.RI "void \fBsetBoundingRect\fP (const QRectF &)"
.br
.ti -1c
.RI "QRectF \fBboundingRect\fP () const "
.br
.ti -1c
.RI "QPolygonF \fBtoPolygonF\fP (const \fBQwtScaleMap\fP &xMap, const \fBQwtScaleMap\fP &yMap, const \fBQwtSeriesData\fP< QPointF > *series, int from, int to) const "
.br
.RI "\fITranslate a series of points into a QPolygonF\&. \fP"
.ti -1c
.RI "QPolygon \fBtoPolygon\fP (const \fBQwtScaleMap\fP &xMap, const \fBQwtScaleMap\fP &yMap, const \fBQwtSeriesData\fP< QPointF > *series, int from, int to) const "
.br
.RI "\fITranslate a series of points into a QPolygon\&. \fP"
.ti -1c
.RI "QPolygon \fBtoPoints\fP (const \fBQwtScaleMap\fP &xMap, const \fBQwtScaleMap\fP &yMap, const \fBQwtSeriesData\fP< QPointF > *series, int from, int to) const "
.br
.RI "\fITranslate a series of points into a QPolygon\&. \fP"
.ti -1c
.RI "QPolygonF \fBtoPointsF\fP (const \fBQwtScaleMap\fP &xMap, const \fBQwtScaleMap\fP &yMap, const \fBQwtSeriesData\fP< QPointF > *series, int from, int to) const "
.br
.RI "\fITranslate a series into a QPolygonF\&. \fP"
.ti -1c
.RI "QImage \fBtoImage\fP (const \fBQwtScaleMap\fP &xMap, const \fBQwtScaleMap\fP &yMap, const \fBQwtSeriesData\fP< QPointF > *series, int from, int to, const QPen &, bool antialiased, uint numThreads) const "
.br
.RI "\fITranslate a series into a QImage\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
A helper class for translating a series of points\&. 

\fBQwtPointMapper\fP is a collection of methods and optimizations for translating a series of points into paint device coordinates\&. It is used by \fBQwtPlotCurve\fP but might also be useful for similar plot items displaying a \fBQwtSeriesData<QPointF>\fP\&. 
.SH "Member Typedef Documentation"
.PP 
.SS "typedef QFlags<\fBTransformationFlag\fP> \fBQwtPointMapper::TransformationFlags\fP"

.PP
Flags affecting the transformation process\&. 
.PP
\fBSee Also:\fP
.RS 4
\fBsetFlag()\fP, \fBsetFlags()\fP 
.RE
.PP

.SH "Member Enumeration Documentation"
.PP 
.SS "enum \fBQwtPointMapper::TransformationFlag\fP"

.PP
Flags affecting the transformation process\&. 
.PP
\fBSee Also:\fP
.RS 4
\fBsetFlag()\fP, \fBsetFlags()\fP 
.RE
.PP

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIRoundPoints \fP\fP
Round points to integer values\&. 
.TP
\fB\fIWeedOutPoints \fP\fP
Try to remove points, that are translated to the same position\&. 
.SH "Member Function Documentation"
.PP 
.SS "QRectF QwtPointMapper::boundingRect () const"

.PP
\fBReturns:\fP
.RS 4
Bounding rectangle 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetBoundingRect()\fP 
.RE
.PP

.SS "\fBQwtPointMapper::TransformationFlags\fP QwtPointMapper::flags () const"

.PP
\fBReturns:\fP
.RS 4
Flags affecting the transformation process 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetFlags()\fP, \fBsetFlag()\fP 
.RE
.PP

.SS "void QwtPointMapper::setBoundingRect (const QRectF &rect)"
Set a bounding rectangle for the point mapping algorithm
.PP
A valid bounding rectangle can be used for optimizations
.PP
\fBParameters:\fP
.RS 4
\fIrect\fP Bounding rectangle 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBboundingRect()\fP 
.RE
.PP

.SS "void QwtPointMapper::setFlag (\fBTransformationFlag\fPflag, boolon = \fCtrue\fP)"
Modify a flag affecting the transformation process
.PP
\fBParameters:\fP
.RS 4
\fIflag\fP Flag type 
.br
\fIon\fP Value
.RE
.PP
\fBSee Also:\fP
.RS 4
flag(), \fBsetFlags()\fP 
.RE
.PP

.SS "void QwtPointMapper::setFlags (\fBTransformationFlags\fPflags)"
Set the flags affecting the transformation process
.PP
\fBParameters:\fP
.RS 4
\fIflags\fP Flags 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBflags()\fP, \fBsetFlag()\fP 
.RE
.PP

.SS "bool QwtPointMapper::testFlag (\fBTransformationFlag\fPflag) const"

.PP
\fBReturns:\fP
.RS 4
True, when the flag is set 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIflag\fP Flag type 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetFlag()\fP, \fBsetFlags()\fP 
.RE
.PP

.SS "QImage QwtPointMapper::toImage (const \fBQwtScaleMap\fP &xMap, const \fBQwtScaleMap\fP &yMap, const \fBQwtSeriesData\fP< QPointF > *series, intfrom, intto, const QPen &pen, boolantialiased, uintnumThreads) const"

.PP
Translate a series into a QImage\&. 
.PP
\fBParameters:\fP
.RS 4
\fIxMap\fP x map 
.br
\fIyMap\fP y map 
.br
\fIseries\fP Series of points to be mapped 
.br
\fIfrom\fP Index of the first point to be painted 
.br
\fIto\fP Index of the last point to be painted 
.br
\fIpen\fP Pen used for drawing a point of the image, where a point is mapped to 
.br
\fIantialiased\fP True, when the dots should be displayed antialiased 
.br
\fInumThreads\fP Number of threads to be used for rendering\&. If numThreads is set to 0, the system specific ideal thread count is used\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Image displaying the series 
.RE
.PP

.SS "QPolygon QwtPointMapper::toPoints (const \fBQwtScaleMap\fP &xMap, const \fBQwtScaleMap\fP &yMap, const \fBQwtSeriesData\fP< QPointF > *series, intfrom, intto) const"

.PP
Translate a series of points into a QPolygon\&. 
.IP "\(bu" 2
WeedOutPoints & \fBboundingRect()\fP\&.isValid() All points that are mapped to the same position will be one point\&. Points outside of the bounding rectangle are ignored\&.
.IP "\(bu" 2
WeedOutPoints & !boundingRect()\&.isValid() All consecutive points that are mapped to the same position will one point
.IP "\(bu" 2
!WeedOutPoints & \fBboundingRect()\fP\&.isValid() Points outside of the bounding rectangle are ignored\&.
.PP
.PP
\fBParameters:\fP
.RS 4
\fIxMap\fP x map 
.br
\fIyMap\fP y map 
.br
\fIseries\fP Series of points to be mapped 
.br
\fIfrom\fP Index of the first point to be painted 
.br
\fIto\fP Index of the last point to be painted
.RE
.PP
\fBReturns:\fP
.RS 4
Translated polygon 
.RE
.PP

.SS "QPolygonF QwtPointMapper::toPointsF (const \fBQwtScaleMap\fP &xMap, const \fBQwtScaleMap\fP &yMap, const \fBQwtSeriesData\fP< QPointF > *series, intfrom, intto) const"

.PP
Translate a series into a QPolygonF\&. 
.IP "\(bu" 2
WeedOutPoints & RoundPoints & \fBboundingRect()\fP\&.isValid() All points that are mapped to the same position will be one point\&. Points outside of the bounding rectangle are ignored\&.
.IP "\(bu" 2
WeedOutPoints & RoundPoints & !boundingRect()\&.isValid() All consecutive points that are mapped to the same position will one point
.IP "\(bu" 2
WeedOutPoints & !RoundPoints All consecutive points that are mapped to the same position will one point
.IP "\(bu" 2
!WeedOutPoints & \fBboundingRect()\fP\&.isValid() Points outside of the bounding rectangle are ignored\&.
.PP
.PP
When RoundPoints is set all points are rounded to integers but returned as PolygonF - what only makes sense when the further processing of the values need a QPolygonF\&.
.PP
\fBParameters:\fP
.RS 4
\fIxMap\fP x map 
.br
\fIyMap\fP y map 
.br
\fIseries\fP Series of points to be mapped 
.br
\fIfrom\fP Index of the first point to be painted 
.br
\fIto\fP Index of the last point to be painted
.RE
.PP
\fBReturns:\fP
.RS 4
Translated polygon 
.RE
.PP

.SS "QPolygon QwtPointMapper::toPolygon (const \fBQwtScaleMap\fP &xMap, const \fBQwtScaleMap\fP &yMap, const \fBQwtSeriesData\fP< QPointF > *series, intfrom, intto) const"

.PP
Translate a series of points into a QPolygon\&. When the WeedOutPoints flag is enabled consecutive points, that are mapped to the same position will be one point\&.
.PP
\fBParameters:\fP
.RS 4
\fIxMap\fP x map 
.br
\fIyMap\fP y map 
.br
\fIseries\fP Series of points to be mapped 
.br
\fIfrom\fP Index of the first point to be painted 
.br
\fIto\fP Index of the last point to be painted
.RE
.PP
\fBReturns:\fP
.RS 4
Translated polygon 
.RE
.PP

.SS "QPolygonF QwtPointMapper::toPolygonF (const \fBQwtScaleMap\fP &xMap, const \fBQwtScaleMap\fP &yMap, const \fBQwtSeriesData\fP< QPointF > *series, intfrom, intto) const"

.PP
Translate a series of points into a QPolygonF\&. When the WeedOutPoints flag is enabled consecutive points, that are mapped to the same position will be one point\&.
.PP
When RoundPoints is set all points are rounded to integers but returned as PolygonF - what only makes sense when the further processing of the values need a QPolygonF\&.
.PP
\fBParameters:\fP
.RS 4
\fIxMap\fP x map 
.br
\fIyMap\fP y map 
.br
\fIseries\fP Series of points to be mapped 
.br
\fIfrom\fP Index of the first point to be painted 
.br
\fIto\fP Index of the last point to be painted
.RE
.PP
\fBReturns:\fP
.RS 4
Translated polygon 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for Qwt User's Guide from the source code\&.
